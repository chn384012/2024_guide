{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 2024 Guide Session 4주차 실습"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''1'''\n",
    "# 필요한 라이브러리를 불러오기\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Jupyter Notebook에서 그래프가 바로 보이도록 설정\n",
    "%matplotlib inline\n",
    "\n",
    "# ignore warnings - 필요없는 경고 메시지 표시 X\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: 'train.csv'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[3], line 3\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[38;5;124;03m'''2'''\u001b[39;00m\n\u001b[0;32m      2\u001b[0m \u001b[38;5;66;03m# 데이터 파일을 불러오기\u001b[39;00m\n\u001b[1;32m----> 3\u001b[0m df_train \u001b[38;5;241m=\u001b[39m pd\u001b[38;5;241m.\u001b[39mread_csv(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mtrain.csv\u001b[39m\u001b[38;5;124m'\u001b[39m)\n\u001b[0;32m      4\u001b[0m df_test \u001b[38;5;241m=\u001b[39m pd\u001b[38;5;241m.\u001b[39mread_csv(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mtest.csv\u001b[39m\u001b[38;5;124m'\u001b[39m)\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:1026\u001b[0m, in \u001b[0;36mread_csv\u001b[1;34m(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\u001b[0m\n\u001b[0;32m   1013\u001b[0m kwds_defaults \u001b[38;5;241m=\u001b[39m _refine_defaults_read(\n\u001b[0;32m   1014\u001b[0m     dialect,\n\u001b[0;32m   1015\u001b[0m     delimiter,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   1022\u001b[0m     dtype_backend\u001b[38;5;241m=\u001b[39mdtype_backend,\n\u001b[0;32m   1023\u001b[0m )\n\u001b[0;32m   1024\u001b[0m kwds\u001b[38;5;241m.\u001b[39mupdate(kwds_defaults)\n\u001b[1;32m-> 1026\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m _read(filepath_or_buffer, kwds)\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:620\u001b[0m, in \u001b[0;36m_read\u001b[1;34m(filepath_or_buffer, kwds)\u001b[0m\n\u001b[0;32m    617\u001b[0m _validate_names(kwds\u001b[38;5;241m.\u001b[39mget(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mnames\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28;01mNone\u001b[39;00m))\n\u001b[0;32m    619\u001b[0m \u001b[38;5;66;03m# Create the parser.\u001b[39;00m\n\u001b[1;32m--> 620\u001b[0m parser \u001b[38;5;241m=\u001b[39m TextFileReader(filepath_or_buffer, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwds)\n\u001b[0;32m    622\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m chunksize \u001b[38;5;129;01mor\u001b[39;00m iterator:\n\u001b[0;32m    623\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m parser\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:1620\u001b[0m, in \u001b[0;36mTextFileReader.__init__\u001b[1;34m(self, f, engine, **kwds)\u001b[0m\n\u001b[0;32m   1617\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39moptions[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mhas_index_names\u001b[39m\u001b[38;5;124m\"\u001b[39m] \u001b[38;5;241m=\u001b[39m kwds[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mhas_index_names\u001b[39m\u001b[38;5;124m\"\u001b[39m]\n\u001b[0;32m   1619\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mhandles: IOHandles \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[1;32m-> 1620\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_engine \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_make_engine(f, \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mengine)\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:1880\u001b[0m, in \u001b[0;36mTextFileReader._make_engine\u001b[1;34m(self, f, engine)\u001b[0m\n\u001b[0;32m   1878\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mb\u001b[39m\u001b[38;5;124m\"\u001b[39m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;129;01min\u001b[39;00m mode:\n\u001b[0;32m   1879\u001b[0m         mode \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mb\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m-> 1880\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mhandles \u001b[38;5;241m=\u001b[39m get_handle(\n\u001b[0;32m   1881\u001b[0m     f,\n\u001b[0;32m   1882\u001b[0m     mode,\n\u001b[0;32m   1883\u001b[0m     encoding\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39moptions\u001b[38;5;241m.\u001b[39mget(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mencoding\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28;01mNone\u001b[39;00m),\n\u001b[0;32m   1884\u001b[0m     compression\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39moptions\u001b[38;5;241m.\u001b[39mget(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mcompression\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28;01mNone\u001b[39;00m),\n\u001b[0;32m   1885\u001b[0m     memory_map\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39moptions\u001b[38;5;241m.\u001b[39mget(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mmemory_map\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28;01mFalse\u001b[39;00m),\n\u001b[0;32m   1886\u001b[0m     is_text\u001b[38;5;241m=\u001b[39mis_text,\n\u001b[0;32m   1887\u001b[0m     errors\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39moptions\u001b[38;5;241m.\u001b[39mget(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mencoding_errors\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mstrict\u001b[39m\u001b[38;5;124m\"\u001b[39m),\n\u001b[0;32m   1888\u001b[0m     storage_options\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39moptions\u001b[38;5;241m.\u001b[39mget(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mstorage_options\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28;01mNone\u001b[39;00m),\n\u001b[0;32m   1889\u001b[0m )\n\u001b[0;32m   1890\u001b[0m \u001b[38;5;28;01massert\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mhandles \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[0;32m   1891\u001b[0m f \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mhandles\u001b[38;5;241m.\u001b[39mhandle\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\io\\common.py:873\u001b[0m, in \u001b[0;36mget_handle\u001b[1;34m(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\u001b[0m\n\u001b[0;32m    868\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(handle, \u001b[38;5;28mstr\u001b[39m):\n\u001b[0;32m    869\u001b[0m     \u001b[38;5;66;03m# Check whether the filename is to be opened in binary mode.\u001b[39;00m\n\u001b[0;32m    870\u001b[0m     \u001b[38;5;66;03m# Binary mode does not support 'encoding' and 'newline'.\u001b[39;00m\n\u001b[0;32m    871\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m ioargs\u001b[38;5;241m.\u001b[39mencoding \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mb\u001b[39m\u001b[38;5;124m\"\u001b[39m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;129;01min\u001b[39;00m ioargs\u001b[38;5;241m.\u001b[39mmode:\n\u001b[0;32m    872\u001b[0m         \u001b[38;5;66;03m# Encoding\u001b[39;00m\n\u001b[1;32m--> 873\u001b[0m         handle \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mopen\u001b[39m(\n\u001b[0;32m    874\u001b[0m             handle,\n\u001b[0;32m    875\u001b[0m             ioargs\u001b[38;5;241m.\u001b[39mmode,\n\u001b[0;32m    876\u001b[0m             encoding\u001b[38;5;241m=\u001b[39mioargs\u001b[38;5;241m.\u001b[39mencoding,\n\u001b[0;32m    877\u001b[0m             errors\u001b[38;5;241m=\u001b[39merrors,\n\u001b[0;32m    878\u001b[0m             newline\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m    879\u001b[0m         )\n\u001b[0;32m    880\u001b[0m     \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[0;32m    881\u001b[0m         \u001b[38;5;66;03m# Binary mode\u001b[39;00m\n\u001b[0;32m    882\u001b[0m         handle \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mopen\u001b[39m(handle, ioargs\u001b[38;5;241m.\u001b[39mmode)\n",
      "\u001b[1;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: 'train.csv'"
     ]
    }
   ],
   "source": [
    "'''2'''\n",
    "# 데이터 파일을 불러오기\n",
    "df_train = pd.read_csv('train.csv')\n",
    "df_test = pd.read_csv('test.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''3'''\n",
    "# train data > 칼럼별로 결측치 비율 확인\n",
    "for col in df_train.columns:\n",
    "    msg = 'column: {:>10}\\t percent of NaN value: {:.2f}%'.format(col, 100 * (df_train[col].isnull().sum() / df_train[col].shape[0]))\n",
    "    print(msg)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''4'''\n",
    "# test data > 칼럼별로 결측치 비율 확인\n",
    "for col in df_test.columns:\n",
    "    msg = 'column: {:>10}\\t percent of NaN value: {:.2f}%'.format(col, 100 * (df_test[col].isnull().sum() / df_test[col].shape[0]))\n",
    "    print(msg)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<span style = \"color:red\"> \n",
    "Q1. 결측치가 있는 칼럼 중, 삭제하는 방식으로 결측치를 처리해야 할 칼럼은 어떤 것인가요?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''5'''\n",
    "### 답\n",
    "# Cabin"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Column별 전처리 및 시각화"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### - 4주차 column: Pclass / Age / Embarked / Fare / Ticket / Cabin"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 1. Pclass: 티켓 클래스 (1 = 1st, 2 = 2nd, 3 = 3rd)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''6'''\n",
    "# Pclass는 순서형, 카테고리 형 데이터 타입이다.\n",
    "df_train['Pclass'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''7'''\n",
    "# Pclass 별 생존자의 인원 분포\n",
    "df_train[['Pclass', 'Survived']].groupby(['Pclass']).sum()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''8'''\n",
    "# 탑승자 분포 확인 \n",
    "fig, ax = plt.subplots(1, 1, figsize=(8, 6))  # 1행 1열의 서브플롯 설정\n",
    "bar1 = df_train[['Pclass', 'Survived']].groupby(['Pclass']).count().plot.bar(ax=ax)\n",
    "bar1.set_title('Pclass - Occupant')\n",
    "plt.xticks(rotation=0)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''9'''\n",
    "# pclass 별 생존자\n",
    "bar2 = sns.countplot(hue='Survived', x='Pclass', data=df_train)\n",
    "bar2.set_title('Pclass - Survived')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''10'''\n",
    "fig, ax = plt.subplots(1,2,figsize=(10,4))\n",
    " \n",
    "# Survived 가 0인 데이터를 이용한 Pie Plot\n",
    "df_train[df_train['Survived'] == 0]['Pclass'].value_counts().sort_index().plot.pie(ax=ax[0], autopct='%1.1f%%')\n",
    "ax[0].set(ylabel='', title='Survived=0 - Pclass')\n",
    " \n",
    "# Survived 가 1인 데이터를 이용한 Pie Plot\n",
    "df_train[df_train['Survived'] == 1]['Pclass'].value_counts().sort_index().plot.pie(ax=ax[1], autopct='%1.1f%%')\n",
    "ax[1].set(ylabel='', title='Survived=1 - Pclass')\n",
    " \n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''11'''\n",
    "# 생존율\n",
    "survival_rate = df_train.groupby('Pclass')['Survived'].mean().reset_index()  \n",
    "survival_rate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''12'''\n",
    "# 객실 등급(Pclass)에 따른 생존율\n",
    "plt.figure(figsize=(10, 6))\n",
    "sns.barplot(x='Pclass', y='Survived', data=survival_rate)\n",
    "plt.title('Survival Rate by Pclass')\n",
    "plt.ylabel('Survival Rate')\n",
    "plt.xlabel('Pclass')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<span style = \"color:red\"> \n",
    "Q2. Pclass와 생존율 사이에 이러한 관계가 나타나는 이유를 추론해보세요."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''13'''\n",
    "### 답\n",
    "# (위치, 구조 순서, 안전 시설 등의 차이)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 2. Age: 나이(세)\n",
    "#### - train data, test data 결측치 有"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''14'''\n",
    "df_train['Age'].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''15'''\n",
    "# 결측치 처리 (수치형 데이터)\n",
    "\n",
    "# 평균으로 대체\n",
    "df_train['Age'].fillna(df_train['Age'].mean(), inplace=True)\n",
    "df_test['Age'].fillna(df_test['Age'].mean(), inplace=True)\n",
    "\n",
    "# (2) 중앙값으로 대체\n",
    "# df_train['Age'].fillna(df_train['Age'].median(), inplace=True)\n",
    "# df_test['Age'].fillna(df_test['Age'].median(), inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''16'''\n",
    "# 정수형으로 변환\n",
    "df_train[\"Age\"] = df_train[\"Age\"].astype(int) \n",
    "df_test[ \"Age\"] = df_test[\"Age\"].astype(int)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<span style = \"color:red\"> \n",
    "Q3. Age 칼럼에 정수형 변환을 적용하는 이유는 무엇일까요?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''17'''\n",
    "### 답\n",
    "# 나이를 소수로 표현할 이유가 없기 때문(측정의 편리성을 위해)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''18'''\n",
    "# Age histogram\n",
    "fig, ax = plt.subplots(figsize=(10,6))\n",
    "sns.histplot(df_train['Age'], bins=25, ax=ax)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''19'''\n",
    "# Age boxplot\n",
    "fig, ax = plt.subplots(figsize=(10, 6))\n",
    "sns.boxplot(x=df_train['Age'], ax=ax)\n",
    "ax.set_title('Age Boxplot')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''20'''\n",
    "# Age(나이)에 따른 생존율\n",
    "\n",
    "# 생존율을 입력받을 list 생성\n",
    "age_range_survival_ratio = []\n",
    "\n",
    "# 1살부터 생존율 구하기\n",
    "for i in range(1, 80):  # 1살부터 79살까지 반복\n",
    "\n",
    "    # i살 미만의 사람들을 필터링\n",
    "    age_group = df_train[df_train['Age'] < i]\n",
    "    \n",
    "    # 해당 나이대의 생존자 수와 전체 인원 수를 구합니다.\n",
    "    survived_count = age_group['Survived'].sum()\n",
    "    total_count = len(age_group)\n",
    "    \n",
    "    # 생존율 계산 (0으로 나누는 것을 방지하기 위해 조건 추가)\n",
    "    if total_count > 0:\n",
    "        survival_ratio = survived_count / total_count  # 전체 인원 중 생존 인원의 비율\n",
    "    else:\n",
    "        survival_ratio = 0\n",
    "    \n",
    "    # 리스트에 생존율 추가\n",
    "    age_range_survival_ratio.append(survival_ratio)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''21'''\n",
    "plt.figure(figsize=(7,7))\n",
    "plt.plot(age_range_survival_ratio)\n",
    "plt.title('Survival Rate by Age')\n",
    "plt.ylabel('Survival Rate')\n",
    "plt.xlabel('Age')\n",
    " \n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''22'''\n",
    "# 생존여부에 따른 Age 분포의 KDE\n",
    "fig, ax = plt.subplots(1, 1, figsize=(9, 5))\n",
    "sns.kdeplot(df_train[df_train['Survived'] == 1]['Age'], ax=ax)\n",
    "sns.kdeplot(df_train[df_train['Survived'] == 0]['Age'], ax=ax)\n",
    "plt.legend(['Survived = 1', 'Survived = 0'])\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<span style = \"color:red\"> \n",
    "Q4. 위의 그래프 결과를 바탕으로 생존자와 비생존자의 나이 분포를 비교해 보세요."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''23'''\n",
    "### 답\n",
    "# 탑승비율에 비해 어린이가 많이 생존함. 20~40대의 사람이 생존율이 낮다. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 3. Embarked: 탑승 항구\n",
    "#### - train data 결측치 有 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''24'''\n",
    "df_train['Embarked'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''25'''\n",
    "# 결측치 처리 (범주형 데이터)\n",
    "# 범주형 데이터라서 평균, 중앙값 활용 X\n",
    "# 최빈값으로 대체\n",
    "most_frequent_embarked = df_train['Embarked'].mode()[0]\n",
    "df_train['Embarked'].fillna(most_frequent_embarked, inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''26'''\n",
    "# Embarked의 데이터 분포\n",
    "fig, ax = plt.subplots(1,2,figsize=(14,5))\n",
    "df_train['Embarked'].value_counts().plot.pie(ax=ax[0], autopct='%1.1f%%')\n",
    "ax[0].set(title='Embarked', ylabel='')\n",
    "sns.countplot(data=df_train, x='Embarked', ax=ax[1])\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''27'''\n",
    "fig, ax = plt.subplots(figsize=(10,6))\n",
    " \n",
    "sns.countplot(data=df_train, x='Embarked', hue='Survived', ax=ax)\n",
    " \n",
    "labels=['Survived=0', 'Survived=1']\n",
    "ax.legend(labels=labels)\n",
    " \n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''28'''\n",
    "# Embarked에 따른 생존율\n",
    "survival_rate = df_train.groupby('Embarked')['Survived'].mean().reset_index()  \n",
    "survival_rate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''29'''\n",
    "# 항구 종류에 따른 생존율\n",
    "sns.barplot(x='Embarked', y='Survived', data=df_train, ci=None)\n",
    "plt.title('Survival Rate by Embarked')\n",
    "plt.xlabel('Embarked')\n",
    "plt.ylabel('Survival Rate')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''30'''\n",
    "# Pclass 별로 데이터 분리 \n",
    "Pclass1 = df_train[df_train['Pclass']==1]['Embarked'].value_counts()\n",
    "Pclass2 = df_train[df_train['Pclass']==2]['Embarked'].value_counts()\n",
    "Pclass3 = df_train[df_train['Pclass']==3]['Embarked'].value_counts()\n",
    "\n",
    "fig, ax = plt.subplots(figsize=(10,7))\n",
    "df = pd.DataFrame([Pclass1, Pclass2, Pclass3])\n",
    "df.index = ['1st class','2nd class','3rd class']\n",
    "df.plot(kind='bar', stacked=True, ax=ax)\n",
    " \n",
    "# xlabel 회전\n",
    "plt.xticks(rotation=45)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''31'''\n",
    "# SibSp, Parch(동승자 유무)와도 연관이 있을까?\n",
    "fig, ax = plt.subplots(1,2,figsize=(13,6))\n",
    " \n",
    "sns.countplot(data=df_train, x='SibSp', hue='Embarked', ax=ax[0])\n",
    "sns.countplot(data=df_train, x='Parch', hue='Embarked', ax=ax[1])\n",
    " \n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''32'''\n",
    "# 혼자 탄 사람이 Class 3에도 많을까?\n",
    "fig, ax = plt.subplots(1,2,figsize=(13,6))\n",
    "sns.countplot(data=df_train, x='SibSp', hue='Pclass', ax=ax[0])\n",
    "sns.countplot(data=df_train, x='Parch', hue='Pclass', ax=ax[1])\n",
    "plt.show()\n",
    "\n",
    "# S항구에서 혼자 Class3에 탄 탑승객의 생존율이 낮다..ㅠㅠ"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<span style = \"color:red\"> \n",
    "Q5. 위의 그래프 결과를 바탕으로 Embarked(탑승항구)/Pclass(티켓 클래스)/SibSp, Parch(동승자 유무)를 생존율과 연관 지어 해석해 보세요."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''33'''\n",
    "### 답\n",
    "# s항구에서 티켓 클래스가 낮고, 동승자가 적을수록 생존율이 낮다. 반대로 c항구에서 티켓 클래스가 높고, 동승자가 있을 경우 생존율이 높았다. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 4. Fare: 탑승 요금 \n",
    "#### - test data 결측치 有 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''34'''\n",
    "df_train['Fare'].describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''35'''\n",
    "# 결측치 처리 (수치형 데이터)\n",
    "\n",
    "# 중앙값으로 대체\n",
    "df_test['Fare'].fillna(df_test['Fare'].median(), inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''36'''\n",
    "# Fare histogram\n",
    "fig, ax = plt.subplots(figsize=(10,6))\n",
    "sns.histplot(df_train['Fare'], bins=25, ax=ax)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''37'''\n",
    "# Fare boxplot # 이상치, 왼쪽부터 min, mean, max.\n",
    "fig, ax = plt.subplots(figsize=(10, 6))\n",
    "sns.boxplot(x=df_train['Fare'], ax=ax)\n",
    "ax.set_title('Fare Boxplot')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''38'''\n",
    "# 이상치 처리 \n",
    "\n",
    "# 1사분위수(Q1)와 3사분위수(Q3)를 계산\n",
    "Q1_fare = df_train['Fare'].quantile(0.25)\n",
    "Q3_fare = df_train['Fare'].quantile(0.75)\n",
    "\n",
    "# IQR (Interquartile Range) 계산\n",
    "IQR_fare = Q3_fare - Q1_fare\n",
    "\n",
    "# 이상치 경계를 설정\n",
    "lower_bound = Q1_fare - 1.5 * IQR_fare\n",
    "upper_bound = Q3_fare + 1.5 * IQR_fare\n",
    "\n",
    "# 이상치를 상한선과 하한선으로 대체\n",
    "df_train['Fare'] = df_train['Fare'].apply(lambda x: upper_bound if x > upper_bound else (lower_bound if x < lower_bound else x))\n",
    "df_test['Fare'] = df_test['Fare'].apply(lambda x: upper_bound if x > upper_bound else (lower_bound if x < lower_bound else x))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''39'''\n",
    "# 생존 여부에 따른 Fare 분포의 KDE\n",
    "# 생존자와 비생존자의 요금 분포를 비교해 볼 수 있다.\n",
    "fig, ax = plt.subplots(1, 1, figsize=(9, 5))\n",
    "sns.kdeplot(df_train[df_train['Survived'] == 1]['Fare'], ax=ax)\n",
    "sns.kdeplot(df_train[df_train['Survived'] == 0]['Fare'], ax=ax)\n",
    "plt.legend(['Survived = 1', 'Survived = 0'])\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''40'''\n",
    "# Pclass(등급)별 Fare(요금) 평균 확인\n",
    "train_fare_means = df_train.groupby('Pclass')['Fare'].mean().reset_index()\n",
    "\n",
    "# 시각화\n",
    "plt.figure(figsize=(10, 6))\n",
    "sns.barplot(x='Pclass', y='Fare', data=train_fare_means)\n",
    "plt.title('Average Fare by Pclass')\n",
    "plt.xlabel('Pclass')\n",
    "plt.ylabel('Average Fare')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 5. Cabin: 객실 넘버\n",
    "#### - train data, test data 결측치 有 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''41'''\n",
    "# 결측치 비율이 70% 이상이므로 칼럼 제거\n",
    "df_train = df_train.drop(columns=['Cabin'])\n",
    "df_test = df_test.drop(columns=['Cabin'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 6. Ticket: 티켓 넘버"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''42'''\n",
    "df_train['Ticket'].unique()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''43'''\n",
    "df_train['Ticket'].value_counts()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<span style = \"color:red\"> \n",
    "Q6. 위의 결과를 바탕으로 데이터셋에서 어떤 사실을 알 수 있는지 고르시오.<br>\n",
    "<span style = \"color:black\"> \n",
    "(1) 모든 승객은 서로 다른 티켓을 소지하고 있다.<br>\n",
    "(2) 동일한 티켓을 소지한 승객이 존재한다.<br>\n",
    "(3) 모든 티켓은 한 번씩만 출현한다.<br>\n",
    "(4) 티켓 번호는 승객의 나이를 나타낸다.\n",
    "</span>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''44'''\n",
    "### 답\n",
    "# (2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''45'''\n",
    "df_train.to_csv('df_train_4.csv', index = False)\n",
    "df_test.to_csv('df_test_4.csv', index = False)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
